<!DOCTYPE html>
<html>
<head>
    <script src="/assets/js/phaser-arcade-physics.min.js"></script>

    <style>
        body {
            background-color: #343a40;
        }

        canvas {
            border: 1px solid #586e75;
        }
    </style>
</head>
<body>

<script>
    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 400,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y: 0},
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);
    var path;
    var curve;
    var graphics;
    var patterns = [];

    // x values
    const left = 50;
    const leftish = 280;
    const centre = 400;
    const rightish = 520;
    const right = 750;

    // y values
    const ground = 380;
    const low = 340;
    const lowish = 300;
    const mid = 200;
    const highish = 100;
    const high = 20;

    function preload ()
    {
        this.load.image('sky', '/assets/images/kilkennySky.png');
        this.load.image('kite', '/assets/images/kite.png');
    }

    function create ()
    {
        this.physics.world.setBounds(0, 0, 800, 390);
        this.add.image(400, 200, 'sky').setDisplaySize(800, 400);
        this.kite = this.physics.add.sprite(400, 380, 'kite').setDisplaySize(45, 25);
        this.kite.setCollideWorldBounds(true);
        patterns = makePatterns(this);

        graphics = this.add.graphics();
        path = { t: 0, vec: new Phaser.Math.Vector2() };
        var startPoint = new Phaser.Math.Vector2(centre, ground);
        var controlPoint1 = new Phaser.Math.Vector2(leftish, low);
        var controlPoint2 = new Phaser.Math.Vector2(left, lowish);
        var endPoint = new Phaser.Math.Vector2(left, mid);

        curve = new Phaser.Curves.CubicBezier(startPoint, controlPoint1, controlPoint2, endPoint);
        this.tweens.add({
            targets: path,
            t: 1,
            ease: 'Sine.easeInOut',
            duration: 2000,
            yoyo: false,
            repeat: 0
        });

        const btnL1 = this.add.text(760, 10, 'L-1', { fill: '#000' });
        btnL1.setInteractive();
        btnL1.on('pointerdown', () => fly(this, patterns[0]));

        const btnL2 = this.add.text(760, 30, 'L-2', { fill: '#000' });
        btnL2.setInteractive();
        btnL2.on('pointerdown', () => fly(this, patterns[1]));

        const btnL3 = this.add.text(760, 50, 'L-3', { fill: '#000' });
        btnL3.setInteractive();
        btnL3.on('pointerdown', () => fly(this, patterns[2]));

        const btnL4 = this.add.text(760, 70, 'L-4', { fill: '#000' });
        btnL4.setInteractive();
        btnL4.on('pointerdown', () => fly(this, patterns[3]));

        const btnL5 = this.add.text(760, 90, 'test', { fill: '#000' });
        btnL5.setInteractive();
        btnL5.on('pointerdown', () => test(this));
    }

    function fly(t, pattern) {
        t.kite.x = centre;
        t.kite.y = ground;
        t.kite.angle = 0;

        var timeline = convertToTweens(t, pattern);
        timeline.play();
    }

    function makePatterns(t) {
        //  [x,      y,   angle, duration, path, ease]
        // angles are multiples of quarter turns
        // with + being clockwise and - anticlockwise.

        var lvl1 = [
            [centre, mid,    0,  1000],
            [centre, mid,   -1,  500],
            [left,   mid,   -1,  1500],
            [left,   mid,    1,  500],
            [right,  mid,    1,  3000],
            [right,  mid,   -1,  500],
            [centre, mid,   -1,  1500],
            [centre, mid,    0,  500],
            [centre, ground, 0,  2000],
        ];
        patterns.push(lvl1);

        var lvl2 = [
            [centre, mid,     0, 1000],
            [centre, mid,    -1,  500],
            [left,   mid,  null,  1500],
            [left,   mid,     1,  500],
            [right,  mid,  null,  3000],
            [right,  mid,    -1,  500],
            [centre, mid,  null,  1500],
            [centre, mid,     3,  1000],
            [left,   mid,    -1,  1500],
            [left,   mid,     1,  500],
            [centre, mid,  null,  1500],
            [centre, mid,    -4, 1000],
            [centre, high,    0, 1000],
            [centre, high,    2,  500],
            [centre, low,  null, 1000],
            [centre, low,     0,  500],
            [centre, ground,  0,  500],
        ];
        patterns.push(lvl2);

        var lvl3 = [
            [centre, mid,      0, 1000],
            [leftish, mid,  null, 1500],
            [leftish, mid,    -8, 1500],
            [rightish, mid, null, 1500],
            [rightish, mid,    8, 1500],
            [centre, mid,   null, 1500],
            [centre, mid,      1,  500],
            [centre, lowish, null, 1000],
            [centre, lowish,  -1,  500],
            [centre, ground, null, 1500],
        ];
        patterns.push(lvl3);

        var lvl4 = [
            [centre, ground,     -2,  500],
            [centre, low,      null, 1000],
            [centre, low,      null, 1000, 'path'],
        ];
        patterns.push(lvl4);
        return patterns;
    }

    function convertToTweens(t, pattern) {
        var follower;

        timeline = t.tweens.createTimeline();

        for (var pCount = 0; pCount < pattern.length; pCount++) {
            var xVal, yVal, ang, dur, es, path;
            xVal = pattern[pCount][0];
            yVal = pattern[pCount][1];
            ang = pattern[pCount][2];
            dur = pattern[pCount][3];
            path = pattern[pCount][4];
            es = pattern[pCount][5];

            if (xVal == null) { xVal = t.kite.x; }
            if (yVal == null) { yVal = t.kite.yVal; }

            // angle
            if (ang != null) {
                ang = ang * 90;
            }

            if (dur == null) { dur = 1000; }
            if (es == null) { es = 'Sine.easeInOut'; }

            if (path != null) {
                follower = { t: 0, vec: new Phaser.Math.Vector2() };
                var startPoint = new Phaser.Math.Vector2(100, 500);
                var controlPoint1 = new Phaser.Math.Vector2(50, 100);
                var endPoint = new Phaser.Math.Vector2(700, 500);

                curve = new Phaser.Curves.QuadraticBezier(startPoint, controlPoint1, endPoint);
                t.tweens.add({
                    targets: follower,
                    t: 1,
                    ease: 'Sine.easeInOut',
                    duration: 2000,
                    yoyo: true,
                    repeat: -1
                });
                /*

                timeline.add({
                    targets: follower,
                    t: 1,
                    angle: ang,
                    duration: dur,
                    ease: es 
                });
                */
            } else {
                if (ang != null) {
                    timeline.add({
                        targets: t.kite,
                        x: xVal,
                        y: yVal,
                        angle: ang,
                        duration: dur,
                        ease: es 
                    });
                } else {
                    timeline.add({
                        targets: t.kite,
                        x: xVal,
                        y: yVal,
                        duration: dur,
                        ease: es
                    });
                }
            }
        }

        return timeline;
    }

    function test(t) {
        var timeline = t.tweens.createTimeline();

        timeline.add({
            targets: t.kite,
            y: 200,
            ease: 'Sine.easeInOut',
            duration: 1000
        });

        timeline.play();
    }

    function makePatternsOrig(t) {
        var timeline = t.tweens.createTimeline();

        timeline.add({
            targets: t.kite,
            y: 200,
            ease: 'Sine.easeInOut',
            duration: 1000
        });

        timeline.add({
            targets: t.kite,
            angle: -90,
            ease: 'Sine.easeInOut',
            duration: 500
        });

        timeline.add({
            targets: t.kite,
            x: 50,
            ease: 'Sine.easeInOut',
            duration: 1500,
        });

        timeline.add({
            targets: t.kite,
            angle: 90,
            ease: 'Sine.easeInOut',
            duration: 500
        });

        timeline.add({
            targets: t.kite,
            x: 750,
            ease: 'Sine.easeInOut',
            duration: 3000
        });

        timeline.add({
            targets: t.kite,
            angle: -90,
            ease: 'Sine.easeInOut',
            duration: 500
        });

        timeline.add({
            targets: t.kite,
            x: 400,
            ease: 'Sine.easeInOut',
            duration: 1500
        });

        timeline.add({
            targets: t.kite,
            angle: 0,
            ease: 'Sine.easeInOut',
            duration: 500
        });

        timeline.add({
            targets: t.kite,
            y: 370,
            ease: 'Sine.easeInOut',
            duration: 2000
        });

        return timeline;
    }

    function update() {
        /*
        graphics.clear();
        graphics.lineStyle(1, 0x00ff00, 1);
        curve.draw(graphics);
        curve.getPoint(path.t, path.vec);
        graphics.fillStyle(0xff0000, 1);
        graphics.fillCircle(path.vec.x, path.vec.y, 16);
        */
    }
</script>

</body>
</html>
